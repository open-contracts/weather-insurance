


Would love to accept PRs adding e.g. !

# Weather Insurance

### Summary

This contract allows anyone to sell a trustless draught insurance policy to anyone else on earth, based on [NASA's ongoing precipitation data feed](https://cmr.earthdata.nasa.gov/search/concepts/C1383813816-GES_DISC.html) measured by the [GPM satellite constellation](https://gpm.nasa.gov/missions/GPM/constellation) via  their [microwave radiometers](https://gpm.nasa.gov/missions/GPM/GMI). Individuals can request an insurance by specifying the conditions under which they want to receive some payout, say "if it rains less than 100L during April 2022 at coordinates XY, pay out 2 ETH", while depositing some insurace fee they would be willing to pay, say 0.5 ETH, into the contract. Any insurer can accept these conditions by depositing the 2 ETH payout amount into the contract, and immediately claim the 0.5 ETH fee. If the insured individual can generate an oracle proof that the draught eventually happened, i.e. it rained less than 100L at XY in April 2022, they can claim their 2 ETH payout. If instead the insurer can prove that it didn't happen, they can reclaim their 2 ETH deposit back.

The idea of using smart contracts to provide weather insurance in countries where it isn't avai

Here are some exciting ways anyone could improve the contract: 
- Add support insuring other types of risks, e.g. fire via [this real-time NASA data feed](https://worldview.earthdata.nasa.gov/?v=-227.166567355547,-113.56806782384763,177.91460589598017,121.72908281176169&l=VIIRS_SNPP_Thermal_Anomalies_375m_Day,VIIRS_SNPP_Thermal_Anomalies_375m_Night,MODIS_Combined_Thermal_Anomalies_All,Reference_Labels_15m(hidden),Reference_Features_15m(hidden),Coastlines_15m,VIIRS_SNPP_CorrectedReflectance_TrueColor(hidden),MODIS_Aqua_CorrectedReflectance_TrueColor(hidden),MODIS_Terra_CorrectedReflectance_TrueColor&lg=false&sh=VIIRS_SNPP_Thermal_Anomalies_375m_Day,C1392010612-LPDAAC_ECS&t=2021-12-29-T16%3A11%3A11Z)
- Add a decentralized mechanism to fairly price insurance policies, e.g. by incentivizing [prediction markets](https://en.wikipedia.org/wiki/Prediction_market) via dedicated token rewards, or create a incentivized machine learning compentition like [Numerai](https://numer.ai/tournament), with an on-chain leaderboard that rewards the best weather prediction performance as validated via oracle enclaves
- Increase capital efficiency by coming up with ways to aggregate uncorrelated risks 

. Design a market which efficiently matches buyers with sellers, maybe by finding a way to create the role of liquidity providers as in [Uniswap](https://uniswap.com/) for example. Integrate with [OpenGSN](https://opengsn.org/) to allow the token-buyer to start without any ETH in their wallet, enabling a trustless fiat-crypto onramp (directly onto L2!). 

### The big picture
There's a lot of spare capital parked on Ethereum. People decided to put it there because they have high hopes for the potential of the technology, and now they would love to put it to productive (and interest-earning) use. For now, there are only few "productive" use-cases for capital in the blockchain world: align the incentives of consensus participants via proof-of-stake, or provide liquidity that allows users to swap tokens, for example. But if we're honest, there's almost no way right now in which this capital could be put to productive use in the _real world_, i.e. to solve problems that have existed before blockchains came around. The consequence: people mostly use their capital to speculate on the prices of NTFs, ERC20s and other tokens. We think this falls fundamentally short of what blockchain capital - which is globally available and has perfect contractual security built-in - _could_ be used for: rent it out or provide insurance to individuals who are inadequately served by existing financial and legal institutions, such as small business owners in low income countries, for example.

But we're missing some key pieces to realize this vision: Ethereum transactions must become cheap without reducing the trustworthiness of the system (shout out to [Arbitrum](https://offchainlabs.com/), [Optimism](https://www.optimism.io/), [ZKSync](https://zksync.io/) and [Polygon](https://polygon.technology/) for huge progess on this!). For loans, we need to empower people to prove to a contract that they have a clean credit history (which becomes possible with our [Proof-Of-ID](https://app.opencontracts.io/#/open-contracts/proof-of-id) idea for example, but also shoutout to the [Proof-Of-Humanity](https://www.proofofhumanity.id/) project!). For insurance, people need to able to prove they actually had a damage (check out our [Weather-Insurance](https://app.opencontracts.io/#/open-contracts/weather-insurance) contract for an example of this!).  And finally, we need to make crypto capital easily convertible to and from local fiat-currencry, wherever you are, because most of the world still runs on it. And that's what this contract is about!

### How it works

Before offering any tokens for sale, the seller first computes a unique `offerID` from the fiat transaction details as follows (e.g. via the `offerID` contract function):
```
offerID = hash(sellerHandle, priceInCent, transactionMessage, paymentService, buyerSellerSecret)
```
Let's explain each of the fiat transaction details: `paymentService` specifies the online payment website (currently it must be the string `"Venmo"`, but eventually `"MPesa"`, `"CashApp"`, etc. could be supported as well). `sellerHandle` is the name of the seller's account on the payment website (currently their Venmo handle). `priceInCent` is an integer specifying how much the buyer has to pay to the seller. `transactionMessage` is a string specifying what message the buyer has to use for their payment. `buyerSellerSecret` is a large, random number generated by the seller.

The `hash` function always produces the same `offerID` from the same transaction details, but you cannot compute the details from a given `offerID` in any other way than randomly trying out all plausible inputs until you find the exact set of inputs that procudes a given `offerID`. This means that as long as `buyerSellerSecret` is a large, random number known only to the buyer and seller, even someone who correctly guesses the `sellerHandle`,`priceInCent`,`transactionMessage` and `paymentService` couldn't figure out that any public `offerID` was produced from those fiat transaction details, because they would have to try out every possible `buyerSellerSecret` as well.

To make an offer to a buyer, the seller calls the `offerTokens` function to deposit their tokens into the contract, specifying their `offerID`, the Ethereum address of the buyer, and the number of seconds the buyer has to claim the offer without fearing that it could be retracted or fulfilled by someone else. Then, the seller shares the fiat transaction details with the buyer, who can compute the corresponding `offerID` and check (via the `weiOffered` function) that they would receive enough tokens for making this fiat transaction. If that is the case, they can make the specified payment, and then call the `buyTokens` function. This will start an oracle enclave, which first receives the transaction details from the buyer and computes the `offerID`. Next, it opens up the website of the payment service in an interactive session, where the user passes 2FA and captchas and shows the enclave that they made the right transaction. If everything checks out, the enclave signs the offerID along with the user's Ethereum address such that the user can submit them to the contract, which then releases the tokens to the user. If the user doesn't submit the proof of payment in time, the seller can call `retractOffer` to get their tokens back from the contract.
